How we generated audio:

Inisde this 'gen_sound_test' folder, there are 5 programs to note, plus a makefile to compile said programs:
	1. change_frequency.c
	2. gen_mem_data.py
	3. load_bram.c
	4. make_binary.py
	5. play_sound.c
	
Programs (1) and (5) were used as a testbench for our custom PWM IP core created in Vivado BEFORE we had implemented the proper driver. Everything else works with the driver.

Programs (2), (3), and (4) all work in tandem to create the baseline audio sample for the theremin, and load this generated sample into our PWM IP's BRAM to be maniplated by our user-space program via our hardware driver. 

Program (2) is a python script that utilizes the 'math' and 'argparse' libraries to generate a simple sin wave inside the 'gen_sine' function.
We define 3 arguments that are to be used in this function:	

	sample_rate:	 This is the number of samples per one period of the waveform. This will be divided by the waveform's frequency to generate the number of samples per second (in this case, just north of 100 samples/sec).
	
	frequency:	 The frequency of the waveform. We chose 440Hz as our baseline audio frequency as it is a standard note in instrument tuning, providing a fair range both higher and lower than the base.
	
	bits_per_sample: The waveform will be parsed into 2^16 bits, which allows us to have a much smoother amplitude thus giving us a smoother overall sound.
	

Our makefile takes programs (2), (3), and (4) and compiles and connects them. The output of program (2) is piped into the input of program (4), creating a new file called 'binary_file.bin'. This is the nature of program (4), it takes a standard input and converts it into a binary file that will in turn be used to load into our PWM IP's BRAM. An object file is then made out of the .bin file that will be compiled and linked to program (3). The binary_data_start and binary_data_end points are both specified in the makefile, and are later used in program (3) itself. 

As the name suggests for program (3), this program will take the binary file generated by program (4) containing the waveform information generated by program (2) and does the heavy lifting of loading the 100 samples into our PWM IP's BRAM, allowing our user-space program to change the rate and scale of the waveform.
